# Design Pattern

> 2021.04.25  苏建锐  East China Normal University

###  1. Command Pattern (命令模式)

命令模式是一种行为型设计模式，它是降低类之间耦合度的一种方式。
命令模式中，将每个具体操作封装成一个个命令，调用者只需要发出特定的命令即可实现相应的功能。各个命令类会自动找到实现这个功能的对象并调用它们的方法。

Definition:

> Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.

为了避免调用者依赖多个对象，命令模式将各种命令封装好后交给调用者。

命令模式一般包含三种角色：

**Receive** 接收者。命令类调用各个接收者的方法来执行相应的命令，接收者是命令的执行者。
**Command** 命令类。将调用者需要使用的命令封装好就是命令类，底层实现是调用各个接收者的方法。
**Invoker** 调用者。调用者负责接收命令，命令发布者只和调用者进行通信，不依赖其他对象，将命令传给调用者，调用者负责执行。



### 2. Decorator Pattern (装饰器模式)

装饰器模式是一种属于结构型的设计模式，它通过一层一层地包装类方式来为类增加新的方法，本质是利用组合，同时也利用了继承。与单纯的继承相比，它更加灵活，因为装饰类之间可以动态地自由组合来添加功能。

装饰器模式是创建一个装饰类来实现接口中的方法，然后利用这个装饰类的各个子类用来装饰实现该接口的各个不同的类。

装饰器模式是递归的设计，多个装饰类的子类可以相互嵌套，实现多次装饰的功能。但无论装饰多少次，被装饰者永远都是装饰器类的子类型。



### 3. State Pattern (状态模式)

状态模式是一种行为型设计模式。当**对象在不同状态下有不同行为时**使用，在该模式中，我们将对象的不同状态
定义成不同的类，在这些状态类下有它们各自的行为，然后利用环境类使客户端在调用时，**不需要显示地去设置状态之间的转换**。

Definition:

> Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.

该模式的本质是**状态的改变引起行为的改变**，从外部看就像该对象所对应的类发生了改变一样。

该模式主要有三种角色：

- **State**——抽象状态角色。
  负责定义各个状态的行为，该抽象状态包含所有具体状态的方法。并且包含环境角色，帮助切换状态。

- **ConcreteState**——具体状态角色。
  实现具体状态下可以执行的行为（不能执行的行为自动切换状态或不做处理）。通常来讲，有多少行为就会产生多少状态。

- **Context**——环境角色。
  该角色是客户端要调用的接口，负责具体状态的切换（客户端不知道状态的切换）。



### 4. Proxy pattern (代理模式)

代理模式属于结构型设计模式。从名字就可以看出它的功能，——**给对象设置代理。**

Definition：

> Provide a surrogate or placeholder for another object to control access to it.

通俗地讲，就是并不想让程序直接访问这个对象，从而给这个对象设置了一个代理，设置代理有很多好处，最直接的就是可以帮助对象**过滤掉一些无意义的访问**。

代理模式主要包括三种角色：

**抽象角色**。负责定义代理角色和真实角色的框架。
**真实角色**。被代理的角色，实现抽象角色，代理者调用它的方法。
**代理角色**。实现抽象角色，调用者通过它调用真实角色的方法。



> 参考CSDN文档，仅供自学使用。